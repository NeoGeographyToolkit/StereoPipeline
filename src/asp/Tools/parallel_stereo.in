#!/usr/bin/env python
# __BEGIN_LICENSE__
#  Copyright (c) 2009-2013, United States Government as represented by the
#  Administrator of the National Aeronautics and Space Administration. All
#  rights reserved.
#
#  The NGT platform is licensed under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance with the
#  License. You may obtain a copy of the License at
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# __END_LICENSE__


import sys, optparse, subprocess, re, os, math, time, tempfile
import shutil
import os.path as P
libexec_path = sys.path[0] + '/../libexec'
sys.path.insert(0, libexec_path) # prepend to Python path
from stereo_utils import * # must be after the path is altered above

# Prepend to system PATH
os.environ["PATH"] = libexec_path + os.pathsep + os.environ["PATH"]

job_pool  = [] # currently running jobs

def produce_tiles( settings, tile_w, tile_h ):
    image_size = settings["trans_left_image_size"]
    tiles_nx = int(math.ceil( float(image_size[0]) / tile_w ))
    tiles_ny = int(math.ceil( float(image_size[1]) / tile_h ))

    tiles = []
    for j in range( tiles_ny ):
        for i in range( tiles_nx ):
            c_tile_w = tile_w
            c_tile_h = tile_h
            if i == tiles_nx - 1:
                c_tile_w = int(image_size[0]) - i * tile_w
            if j == tiles_ny - 1:
                c_tile_h = int(image_size[1]) - j * tile_h
            tiles.append(BBox(i*tile_w,j*tile_h,c_tile_w,c_tile_h))

    return tiles;

def add_job( cmd ):
    sleep_time = 0.001
    while ( len(job_pool) >= opt.processes ):
        for i in range(len(job_pool)):
            if ( job_pool[i].poll() is not None ):
                job_pool.pop(i)
                job_pool.append( subprocess.Popen(cmd) )
                return
        time.sleep( sleep_time )
        sleep_time = (sleep_time * 5) % 60
    job_pool.append( subprocess.Popen(cmd) )

def wait_on_all_jobs():
    print "Waiting for jobs to finish";
    sleep_time = 1
    while len(job_pool) > 0:
        for i in range(len(job_pool)):
            if ( job_pool[i].poll() is not None ):
                job_pool.pop(i)
                break # must restart as array changed size
        time.sleep( sleep_time )

def wipe_option(options, opt, n):
    # In the array 'options', find the entry with value 'opt'.
    # Wipe this entry and the next n values.
    while opt in options:
        r = options.index(opt)
        if r < len(options): del options[r] # rm 'opt'
        for i in range(n):
            if r < len(options): del options[r]

def create_subproject_dirs( settings, **kw ):
    for tile in produce_tiles( settings, opt.job_size_w, opt.job_size_h ):
        directory = settings['out_prefix'][0] + tile.name_str()
        prefix    = directory + "/" + tile.name_str()
        relation = os.path.relpath(settings['out_prefix'][0],directory)
        if opt.dryrun:
            print "mkdir -p %s" % directory
            print "soft linking via %s %s" % (prefix, relation)
        else:
            try:
                os.mkdir( directory )
            except OSError, e:
                pass
            # To do: A more robust approach below would be to soft-link
            # all existing files rather than having a list.
            for postfix in ["-L.tif","-R.tif","-L_sub.tif","-R_sub.tif",
                            "-lMask.tif","-rMask.tif","-lMask_sub.tif",
                            "-rMask_sub.tif","-align-L.exr","-align-R.exr","-F.tif",
                            "-D_sub.tif", "-D_sub_spread.tif", "-local_hom.txt",
                            "-"+os.path.basename(settings['in_file1'][0])[:-4]+"__"+
                            os.path.basename(settings['in_file2'][0])[:-4]+".match"]:
                if os.path.lexists( prefix + postfix ):
                    os.remove( prefix + postfix )
                os.symlink( relation + postfix, prefix + postfix )

def build_vrt( settings, postfix, num_bands=4, data_type="float", **kw ):

    image_size = settings["trans_left_image_size"]
    with open(settings['out_prefix'][0]+postfix,'w') as f:
        f.write("<VRTDataset rasterXSize=\"%i\" rasterYSize=\"%i\">\n" % (int(image_size[0]),int(image_size[1])) )
        for b in range( 1, num_bands + 1 ):
            f.write("  <VRTRasterBand dataType=\"%s\" band=\"%i\">\n" % (data_type,b) )

            tiles = produce_tiles( settings, opt.job_size_w, opt.job_size_h )

            # If a tile is missing, for example, in the case we
            # skipped it when it does not intersect user's crop box,
            # substitute it with a different one, to ensure the mosaic
            # does not have holes.
            goodFilename = ""
            for tile in tiles:
                directory = settings['out_prefix'][0] + tile.name_str()
                filename  = directory + "/" + tile.name_str() + postfix
                if os.path.isfile(filename):
                    goodFilename = filename
                    break
            if goodFilename == "":
                raise Exception('No tiles were generated')

            for tile in tiles:
                directory = settings['out_prefix'][0] + tile.name_str()
                filename  = directory + "/" + tile.name_str() + postfix

                if not os.path.isfile(filename): filename = goodFilename

                relative  = os.path.relpath(filename, os.path.dirname( settings['out_prefix'][0] ) )
                f.write("    <SimpleSource>\n")
                f.write("       <SourceFilename relativeToVRT=\"1\">%s</SourceFilename>\n" % relative)
                f.write("       <SourceBand>%i</SourceBand>\n" % b)
                f.write("       <SrcRect xOff=\"%i\" yOff=\"%i\" xSize=\"%i\" ySize=\"%i\"/>\n" %
                        (tile.x, tile.y, tile.width, tile.height) )
                f.write("       <DstRect xOff=\"%i\" yOff=\"%i\" xSize=\"%i\" ySize=\"%i\"/>\n" %
                        (tile.x, tile.y, tile.width, tile.height) )
                f.write("    </SimpleSource>\n")
            f.write("  </VRTRasterBand>\n")
        f.write("</VRTDataset>\n")


def get_num_nodes(nodes_list):

    if nodes_list is None:
        return 1 # local machine

    # Count the number of nodes without repetition
    # (need this for Pleiades).
    nodes = {}
    num_nodes = 0
    try:
        fh = open(nodes_list, "r")
        for line in fh:
            if re.match('^\s*$', line): continue # skip empty lines
            matches = re.match('^\s*([^\s]*)', line)
            if matches:
                nodes[matches.group(1)] = 1

        num_nodes = len(nodes)
    except Exception, e:
        die(e)
    if num_nodes == 0:
        raise Exception('The list of computing nodes is empty')

    return num_nodes

# Create copies of the run manager on multiple machines.
# Those will in turn launch the jobs on those machines.
def sprawn_to_nodes(start, stop, num_nodes, settings, args):

    # Each node gets an id
    ids = [];
    for i in range(num_nodes): ids += [str(i)]

    # Use GNU parallel
    cmd = ['parallel', '-u', '-P', '1']
    if which(cmd[0]) is None:
        raise Exception('Need GNU Parallel to distribute the jobs.')

    if opt.nodes_list is not None:
        cmd += ['--sshloginfile', opt.nodes_list]

    # The options which we want GNU parallel to not mess up with.
    # Put them into a single string.
    args_str = " ".join(args) + " --entry-point " + str(start) + \
               " --stop-point " + str(stop) + " --work-dir " + opt.work_dir
    if opt.isisroot  is not None: args_str += " --isisroot "  + opt.isisroot
    if opt.isis3data is not None: args_str += " --isis3data " + opt.isis3data
    args_str += " --rank {}"

    cmd += [args_str, ':::'] + ids # GNU parallel syntax

    if opt.verbose:
        print(" ".join(cmd))

    code = subprocess.call(cmd)
    if code != 0:
        raise Exception('parallel_stereo call for step ' + str(start) + ' failed')

# Launch jobs on the current machine
def parallel_run(bin, args, settings, tiles, **kw):
    binpath = P.join(kw.get('path', P.dirname(P.abspath(__file__))), '..', 'bin', bin)
    call = [binpath]
    call.extend(args)

    if opt.threads_multi is not None:
        wipe_option(call, '--threads', 1)
        call.extend(['--threads', str(opt.threads_multi)])

    # Will do only the tiles intersecting user's crop window.
    w = settings['transformed_window']
    user_crop_win = BBox(int(w[0]), int(w[1]), int(w[2]), int(w[3]))
    try:
        for tile in tiles:

            crop_box = intersect_boxes(user_crop_win, tile)
            if crop_box.width <= 0 or crop_box.height <= 0: continue
            crop_str = crop_box.crop_str()

            cmd = call+crop_str
            cmd[cmd.index( settings['out_prefix'][0] )] = settings['out_prefix'][0] + tile.name_str() + "/" + tile.name_str()
            if opt.dryrun:
                print " ".join(cmd)
            else:
                add_job( cmd )
        if opt.dryrun:
            return
        wait_on_all_jobs()
    except OSError, e:
        raise Exception('%s: %s' % (binpath, e))

def single_run(bin, args, **kw):

    binpath = P.join(kw.get('path', P.dirname(P.abspath(__file__))), '..', 'bin', bin)
    call = [binpath]
    call.extend(args)

    if opt.threads_single is not None:
        wipe_option(call, '--threads', 1)
        call.extend(['--threads', str(opt.threads_single)])

    if opt.dryrun:
        print '%s' % ' '.join(call)
        return
    try:
        code = subprocess.call(call)
    except OSError, e:
        raise Exception('%s: %s' % (binpath, e))
    if code != 0:
        raise Exception('Stereo step ' + kw['msg'] + ' failed')

if __name__ == '__main__':
    usage = '''parallel_stereo [options] <Left_input_image> <Right_input_image>
              [Left_camera_file] [Right_camera_file] <output_file_prefix> [DEM]
        Extensions are automaticaly added to the output files.
        Camera model arguments may be optional for some stereo
        session types (e.g. isis). Stereo parameters should be
        set in the stereo.default file.

  [ASP [@]ASP_VERSION[@]]'''

    # What makes this program different from stereo.in is that it
    # tries to treat ASP as a multi-process system instead of a
    # multi-threaded executable. This has benefits on the super
    # computer by allowing a single stereo pair use multiple
    # computers. It also allows us to get past the single-threaded
    # constraints of ISIS.

    # Algorithm: When the script is started, it starts one copy of
    # itself on each node if doing steps 1, 2, or 4 (corr, rfne, tri).
    # Those scripts in turn start actual jobs on those nodes.
    # For the other steps, the script does the work itself.

    p = PassThroughOptionParser(usage=usage)
    p.add_option('--nodes-list',              dest='nodes_list',   default=None,
                 help='The list of computing nodes, one per line.')
    p.add_option('--processes',            dest='processes',   default=4,     type='int',
                 help='The number of processes to use per node.')
    p.add_option('--threads-multiprocess', dest='threads_multi', default=2,   type='int',
                 help='The number of threads to use per process.')
    p.add_option('--threads-singleprocess',dest='threads_single',default=None,type='int',
                 help='The number of threads to use when running a single process (PPRC and FLTR).')
    p.add_option('--corr-seed-mode',    dest='seed_mode', default=1,
                 help='Correlation seed strategy. See stereo_pprc for options.', type='int')
    p.add_option('-e', '--entry-point',    dest='entry_point', default=0,
                 help='Stereo Pipeline entry point (an integer from 0-5).', type='int')
    p.add_option('--stop-point',           dest='stop_point',  default=6,
                 help='Stereo Pipeline stop point (an integer from 1-6).', type='int')
    p.add_option('--job-size-w',           dest='job_size_w',  default=2048,
                 help='Pixel width of input image tile for a single process.', type='int')
    p.add_option('--job-size-h',           dest='job_size_h',  default=2048,
                 help='Pixel height of input image tile for a single process.', type='int')
    p.add_option('-v', '--version',        dest='version',     default=False, action='store_true',
                 help='Display the version of software.')

    # Internal variables below.
    # The rank of the sprawned process (0 <= rank < num_nodes).
    p.add_option('--rank',      dest='rank', default=None, type='int',
                 help=optparse.SUPPRESS_HELP)
    # Directory where the job is running
    p.add_option('--work-dir',  dest='work_dir', default=None,
                 help=optparse.SUPPRESS_HELP)
    # ISIS settings
    p.add_option('--isisroot',  dest='isisroot', default=None,
                 help=optparse.SUPPRESS_HELP)
    p.add_option('--isis3data', dest='isis3data', default=None,
                 help=optparse.SUPPRESS_HELP)
    # Debug options
    p.add_option('--dry-run',   dest='dryrun', default=False, action='store_true',
                 help=optparse.SUPPRESS_HELP)
    p.add_option('--verbose',   dest='verbose', default=False, action='store_true',
                 help=optparse.SUPPRESS_HELP)

    global opt
    (opt, args) = p.parse_args()

    if opt.seed_mode is not None:
        args.extend(['--corr-seed-mode', str(opt.seed_mode)])

    if opt.rank is None:
        # When the script is started, set some options from the
        # environment which we will pass to the scripts we sprawn
        # 1. Set the work directory
        opt.work_dir = os.getcwd()
        # 2. Set the ISIS settings if any
        if 'ISISROOT'  in os.environ: opt.isisroot  = os.environ['ISISROOT']
        if 'ISIS3DATA' in os.environ: opt.isis3data = os.environ['ISIS3DATA']
        # 3. Fix for Pleiades, copy the nodes_list to current directory
        if opt.nodes_list is not None:
            tmpFile = tempfile.NamedTemporaryFile(delete=True, dir='.')
            shutil.copy2(opt.nodes_list, tmpFile.name)
            opt.nodes_list = tmpFile.name
            wipe_option(sys.argv, '--nodes-list', 1)
            sys.argv.extend(['--nodes-list', tmpFile.name])
    else:
        # After the script spawns itself to nodes, it starts in the
        # home dir. Make it go to the right place.
        os.chdir(opt.work_dir)
        # Set the ISIS settings
        if opt.isisroot  is not None: os.environ['ISISROOT']  = opt.isisroot
        if opt.isis3data is not None: os.environ['ISIS3DATA'] = opt.isis3data

    num_nodes = get_num_nodes(opt.nodes_list)

    if not args and not opt.version:
        p.print_help()
        die('\nERROR: Missing input files', code=2)

    if opt.version:
        args.append('-v')

    args=unescape_vals(args)

    args_sub = args[:] # deep copy
    args_sub.extend(['--compute-low-res-disparity-only'])

    settings=run_and_parse_output( "stereo_parse", args, opt.verbose )

    if opt.rank is None:

        # We get here when the script is started. The current running
        # process has become the management process that spawns other
        # copies of itself on other machines. This block will only do
        # actual work when we hit a non-multiprocess step like PPRC or
        # FLTR.

        create_subproject_dirs( settings )

        # Wipe options which we will override.
        self_args = sys.argv # shallow copy
        wipe_option(self_args, '-e', 1)
        wipe_option(self_args, '--entry-point', 1)
        wipe_option(self_args, '--stop-point', 1)

        if ( opt.entry_point <= 0 ):
            # Preprocessing
            single_run('stereo_pprc', args, msg='0: Preprocessing')
            # Now the left is defined. Regather the settings
            # and properly create the project dirs.
            settings=run_and_parse_output( "stereo_parse", args, opt.verbose )
            create_subproject_dirs( settings )
        if ( opt.entry_point <= 1 ):
            # Correlation. First do low-res.
            if ( opt.stop_point <= 1 ): sys.exit()
            if ( opt.seed_mode == 3 ):
                run_sparse_disp(args, opt)
            else:
                single_run('stereo_corr', args_sub, msg='1: Low-res correlation')
            sprawn_to_nodes(1, 2, num_nodes, settings, self_args)
        if ( opt.entry_point <= 2 ):
            # Refinement
            if ( opt.stop_point <= 2 ): sys.exit()
            sprawn_to_nodes(2, 3, num_nodes, settings, self_args)
        if ( opt.entry_point <= 3 ):
            # Filtering
            if ( opt.stop_point <= 3 ): sys.exit()
            build_vrt( settings, "-RD.tif", 3, "Float32" );
            single_run('stereo_fltr', args, msg='3: Filtering')
        if ( opt.entry_point <= 4 ):
            # Triangulation
            if ( opt.stop_point <= 4 ): sys.exit()
            sprawn_to_nodes(4, 5, num_nodes, settings, self_args)
        if ( opt.entry_point <= 5 ):
            # Point cloud mosaic
            if ( opt.stop_point <= 5 ): sys.exit()
            build_vrt( settings, "-PC.tif", 4, "Float64" )

    else:

        # Launch multiple processes doing actual work on the current
        # machine for the current entry point.
        if opt.verbose:
            print("Running on machine: ", os.uname())

        try:

            # Define the tiles that we'll be processing on
            tiles = produce_tiles( settings, opt.job_size_w, opt.job_size_h );

            # We are processing the jobs that correspond to the
            # fraction 1 / num_nodes and are at index opt.rank.
            num_tiles = len(tiles)
            min_index = int((float(opt.rank)/float(num_nodes)) * num_tiles)
            max_index = int(((float(opt.rank)+1)/float(num_nodes)) * num_tiles)
            tiles = tiles[min_index:max_index]

            if ( opt.entry_point == 1 ):
                parallel_run('stereo_corr', args, settings, tiles, msg='1: Correlation')
            if ( opt.entry_point == 2 ):
                parallel_run('stereo_rfne', args, settings, tiles, msg='2: Refinement')
                build_vrt( settings, "-RD.tif", 3, "Float32" );
            if ( opt.entry_point == 4 ):
                parallel_run('stereo_tri', args, settings, tiles, msg='4: Triangulation')

        except Exception, e:
            die(e)
            raise
