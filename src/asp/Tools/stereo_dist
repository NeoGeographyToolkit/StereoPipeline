#!/usr/bin/env python
# __BEGIN_LICENSE__
#  Copyright (c) 2009-2026, United States Government as represented by the
#  Administrator of the National Aeronautics and Space Administration. All
#  rights reserved.
#
#  The NGT platform is licensed under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance with the
#  License. You may obtain a copy of the License at
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# __END_LICENSE__

"""
stereo_dist - Distributed stereo processing.
"""

import sys, argparse, subprocess, re, os, math, time, glob, shutil, platform
import os.path as P

# Set up the path to Python modules about to load
basepath    = os.path.abspath(sys.path[0])
pythonpath  = os.path.abspath(basepath + '/../Python')  # for dev ASP
libexecpath = os.path.abspath(basepath + '/../libexec') # for packaged ASP
sys.path.insert(0, basepath) # prepend to Python path
sys.path.insert(0, pythonpath)
sys.path.insert(0, libexecpath)

import asp_system_utils, asp_string_utils, asp_cmd_utils
asp_system_utils.verify_python_version_is_supported()
from asp_stereo_utils import * # must be after the path is altered above

# Prepend to system PATH
os.environ["PATH"] = libexecpath + os.pathsep + os.environ["PATH"]

# Ensure we can look up the ASP libraries
if 'ASP_LIBRARY_PATH' in os.environ:
    os.environ['LD_LIBRARY_PATH'] = os.environ['ASP_LIBRARY_PATH']

def runStereoTiles(opt, args, outPrefix, tileEntryPoint, tileStopPoint):
    '''Run stereo_tile on all tiles using GNU Parallel.'''

    tiles = readDistTileList(outPrefix)
    numTiles = len(tiles)
    if numTiles == 0:
        raise Exception('No tiles found in tile list.')

    print('Running stereo_tile on ' + str(numTiles) + ' tiles.')

    # Write argument file (one tile index per line)
    argumentFilePath = outPrefix + '-tileArgs.txt'
    with open(argumentFilePath, 'w') as f:
        for i in range(numTiles):
            f.write(str(i) + '\n')

    # Set up GNU parallel arguments
    parallelArgs = ['--will-cite', '--env', 'ASP_DEPS_DIR',
                    '--env', 'PATH', '--env', 'LD_LIBRARY_PATH',
                    '--env', 'ASP_LIBRARY_PATH', '--env', 'ISISROOT']

    if opt.parallel_options is not None:
        parallelArgs += opt.parallel_options.split(' ')

    # Determine number of processes
    numProcesses = opt.processes
    if numProcesses is None:
        numProcesses = asp_system_utils.get_num_cpus()

    # Build stereo_tile command with placeholder for tile index
    pythonPath = sys.executable
    stereoTilePath = asp_system_utils.bin_path('stereo_tile')
    commandList = [pythonPath, stereoTilePath,
                   '--tile-index', '{1}',
                   '--entry-point', str(tileEntryPoint),
                   '--stop-point', str(tileStopPoint)]

    if opt.dem:
        commandList += ['--dem', opt.dem]
    if opt.point2dem_options:
        commandList += ['--point2dem-options', opt.point2dem_options]

    if opt.verbose:
        commandList.append('--verbose')
    if opt.dryrun:
        commandList.append('--dry-run')

    commandList += args

    # Prepend parallel args to command
    fullCommandList = parallelArgs + commandList

    if opt.dryrun:
        print('Run GNU parallel with ' + str(numProcesses) + ' processes')
        print('Command: ' + ' '.join(fullCommandList))
        return

    asp_system_utils.runInGnuParallel(numProcesses, argumentFilePath,
                                      fullCommandList, opt.nodes_list, opt.verbose)

def runBlockMosaic(opt, masterFile):
    '''Run dem_mosaic in parallel on blocks via GNU Parallel.
    Each job reads one line from masterFile by index and runs dem_mosaic.'''

    # Count blocks in master file
    with open(masterFile, 'r') as f:
        lines = [l.strip() for l in f if l.strip()]
    numBlocks = len(lines)
    if numBlocks == 0:
        raise Exception('No blocks in master file: ' + masterFile)

    print('Running dem_mosaic on ' + str(numBlocks) + ' blocks.')

    # Write argument file (one block index per line, 0-based)
    argumentFilePath = masterFile.replace('.txt', '-args.txt')
    with open(argumentFilePath, 'w') as f:
        for i in range(numBlocks):
            f.write(str(i) + '\n')

    # Set up GNU parallel arguments
    parallelArgs = ['--will-cite', '--env', 'ASP_DEPS_DIR',
                    '--env', 'PATH', '--env', 'LD_LIBRARY_PATH',
                    '--env', 'ASP_LIBRARY_PATH', '--env', 'ISISROOT']

    if opt.parallel_options is not None:
        parallelArgs += opt.parallel_options.split(' ')

    # Determine number of processes
    numProcesses = opt.processes
    if numProcesses is None:
        numProcesses = asp_system_utils.get_num_cpus()

    # Build bash -c command that reads the master file at the given index
    # and runs dem_mosaic. {1} is the 0-based block index from the argument
    # file. sed -n uses 1-based line numbers, so add 1.
    demMosaicPath = asp_system_utils.bin_path('dem_mosaic')
    bashScript = ('line=$(sed -n "$(({1}+1))p" ' + masterFile + '); '
                  + demMosaicPath +
                  ' --dem-list "${line%% *}" -o "${line##* }"')
    commandList = ['bash', '-c', bashScript]

    # Prepend parallel args to command
    fullCommandList = parallelArgs + commandList

    if opt.dryrun:
        print('Run GNU parallel with ' + str(numProcesses) + ' processes')
        print('Command: ' + ' '.join(fullCommandList))
        return

    asp_system_utils.runInGnuParallel(numProcesses, argumentFilePath,
                                      fullCommandList, opt.nodes_list,
                                      opt.verbose)

def mosaicDems(opt, outPrefix):
    '''Collect per-tile DEMs and mosaic them in parallel blocks.'''

    # Read the list of tiles
    tiles = readDistTileList(outPrefix)
    numTiles = len(tiles)
    if numTiles == 0:
        raise Exception('No tiles found in tile list.')

    # Collect DEM files that exist
    demFiles = []
    for (tile, padding) in tiles:
        tileSubdir = outPrefix + '-' + tile.name_str()
        tilePrefix = tileSubdir + '/' + os.path.basename(outPrefix)
        demFile = tilePrefix + '-DEM.tif'
        if os.path.exists(demFile):
            demFiles.append(demFile)

    if len(demFiles) == 0:
        raise Exception('No DEM files found in tile directories.')

    print('Found ' + str(len(demFiles)) + ' DEM files to mosaic.')

    # Simple single-process mosaic of all tile DEMs
    demListFile = outPrefix + '-demList.txt'
    with open(demListFile, 'w') as f:
        for d in demFiles:
            f.write(d + '\n')
    finalDem = outPrefix + '-DEM.tif'
    demMosaicPath = asp_system_utils.bin_path('dem_mosaic')
    commandList = [demMosaicPath, '--dem-list', demListFile, '-o', finalDem]
    print('Running: ' + ' '.join(commandList))
    if not opt.dryrun:
        subprocess.call(commandList)
    return
    
    # This more fancy version needs to be tested and tuned. For now will return
    # right above after the simple version does the job.
     
    # Will first mosaic with several batches then merge the results. This seems
    # to be the sweet spot for I/O and performance.
    
    # Compute tile grid size and number of parallel jobs
    (numCols, numRows) = tileGridSize(tiles)
    print('Tile grid: ' + str(numCols) + ' cols x ' + str(numRows) + ' rows')

    numJobs = numMosaicJobs(opt.nodes_list, opt.processes)
    print('Initial num mosaic jobs: ' + str(numJobs))

    # Each block must have at least 2 tiles
    # TODO(oalexan1): Increase this to 4 tiles
    maxJobs = (numCols * numRows) // 2
    
    numJobs = max(min(numJobs, maxJobs), 1)
    print('Num mosaic jobs after capping: ' + str(numJobs))
    
    # TODO(oalexan1): Must handle at the end if we have just one job

    # Divide tile grid into blocks matching the aspect ratio
    aspect = float(numCols) / float(max(numRows, 1))
    print("--aspect is " + str(aspect))
    
    blockCols = int(round(math.sqrt(numJobs * aspect)))
    blockRows = int(round(numJobs / float(max(blockCols, 1))))
    blockCols = max(blockCols, 1)
    blockRows = max(blockRows, 1)
    blockCols = min(blockCols, numCols)
    blockRows = min(blockRows, numRows)
    print('Block grid: ' + str(blockCols) + ' x ' + str(blockRows) +
          ' = ' + str(blockCols * blockRows) + ' blocks')

    # Compute tiles per block in each dimension
    tilesPerBlockX = int(math.ceil(numCols / blockCols))
    tilesPerBlockY = int(math.ceil(numRows / blockRows))
    print('Tiles per block: ' + str(tilesPerBlockX) + ' x ' +
          str(tilesPerBlockY))

    # Build sorted lists of distinct tile starting corner coordinates
    tileStartCornerX = sorted(set(tile.x for (tile, padding) in tiles))
    tileStartCornerY = sorted(set(tile.y for (tile, padding) in tiles))

    # Build a map from (x, y) origin to DEM file path
    demMap = {}
    for (tile, padding) in tiles:
        tileSubdir = outPrefix + '-' + tile.name_str()
        tilePrefix = tileSubdir + '/' + os.path.basename(outPrefix)
        demFile = tilePrefix + '-DEM.tif'
        if os.path.exists(demFile):
            demMap[(tile.x, tile.y)] = demFile

    # Keep track of each partial DEM mosaic name and of the list of DEMs
    # that goes into making it.
    masterList = []

    # Assign tiles to blocks. For each block, find which tile grid columns
    # and rows it covers, convert grid indices to pixel origins via
    # tileStartCornerX/Y, and look up the DEM file in demMap.
    for by in range(blockRows):
        for bx in range(blockCols):
            # Range of tile indices for this block
            colStart = bx * tilesPerBlockX
            colEnd = min((bx + 1) * tilesPerBlockX, numCols)
            rowStart = by * tilesPerBlockY
            rowEnd = min((by + 1) * tilesPerBlockY, numRows)

            blockDems = []
            for ci in range(colStart, colEnd):
                for ri in range(rowStart, rowEnd):
                    # Tile corner in pixel coordinates
                    key = (tileStartCornerX[ci], tileStartCornerY[ri])
                    if key in demMap:
                        # Collect DEMs that exist
                        blockDems.append(demMap[key])

            # Skip empty blocks
            if len(blockDems) == 0:
                continue

            # Write this block's DEM list file
            blockIndex = len(masterList)
            blockDemListFile = outPrefix + '-mosaicBlock_' + str(blockIndex) + '.txt'
            blockOutputDem = outPrefix + '-mosaicBlock_' + str(blockIndex) + '-DEM.tif'
            with open(blockDemListFile, 'w') as f:
                for d in blockDems:
                    f.write(d + '\n')

            masterList.append((blockDemListFile, blockOutputDem))
            print('Block ' + str(blockIndex) + ' (' + str(bx) + ', ' +
                  str(by) + '): ' + str(len(blockDems)) + ' DEMs, list: ' +
                  blockDemListFile)

    # Write master file
    masterFile = outPrefix + '-mosaicMaster.txt'
    with open(masterFile, 'w') as f:
        for (listFile, outputDem) in masterList:
            f.write(listFile + ' ' + outputDem + '\n')
    print('Wrote master mosaic file: ' + masterFile + ' with ' +
          str(len(masterList)) + ' blocks')

    finalDem = outPrefix + '-DEM.tif'

    if len(masterList) == 1:
        # Single block - just run dem_mosaic directly, no parallel overhead
        demMosaicPath = asp_system_utils.bin_path('dem_mosaic')
        commandList = [demMosaicPath, '--dem-list', masterList[0][0],
                       '-o', finalDem]
        print('Single block mosaic: ' + ' '.join(commandList))
        if not opt.dryrun:
            subprocess.call(commandList)
    else:
        # Run parallel dem_mosaic per block
        runBlockMosaic(opt, masterFile)

        # Final merge of block DEMs into outPrefix-DEM.tif
        blockDemFiles = [outputDem for (listFile, outputDem) in masterList]
        # Filter to existing files
        blockDemFiles = [f for f in blockDemFiles if os.path.exists(f)]
        if len(blockDemFiles) == 0:
            raise Exception('No block DEM files were produced.')

        print('Merging ' + str(len(blockDemFiles)) + ' block DEMs into ' + finalDem)
        demMosaicPath = asp_system_utils.bin_path('dem_mosaic')
        commandList = [demMosaicPath] + blockDemFiles + ['-o', finalDem]
        if not opt.dryrun:
            if opt.verbose:
                print(' '.join(commandList))
            subprocess.call(commandList)

if __name__ == '__main__':
    usage = '''stereo_dist [options] <images> [<cameras>]
                  <output_file_prefix>
        Distributed stereo processing.\n''' + asp_system_utils.get_asp_version()

    p = argparse.ArgumentParser(usage=usage)
    p.add_argument('-v', '--version', dest='version', default=False, action='store_true',
                   help='Display the version of software.')
    p.add_argument('--verbose', dest='verbose', default=False, action='store_true',
                   help='Display the commands being executed.')
    p.add_argument('--dry-run', dest='dryrun', default=False, action='store_true',
                   help='Do not launch the jobs, only print the commands that should be run.')
    p.add_argument('--tile-size', dest='tile_size', default=2048, type=int,
                   help='Size of each tile for distributed processing. This is before the padding is added.')
    p.add_argument('--tile-padding', dest='tile_padding', default=256, type=int,
                   help='Padding around each tile to avoid boundary artifacts.')
    p.add_argument('--threads-multiprocess', dest='threads_multi', default=None, type=int,
                   help='The number of threads to use per process when running multiple '
                   'processes.')
    p.add_argument('--threads-singleprocess', dest='threads_single', default=None, type=int,
                   help='The number of threads to use when running a single process '
                   '(PPRC and FLTR).')
    p.add_argument('-e', '--entry-point', dest='entry_point', default=0, type=int,
                   help='Stereo pipeline entry point (default: 0). Values: 0=pprc, '
                   '1=corr, 2=blend, 3=rfne, 4=fltr, 5=tri, 6=cleanup, 7=dem, '
                   '8=mosaic.')
    p.add_argument('--stop-point', dest='stop_point', default=9, type=int,
                   help='Stereo pipeline stop point, stop before this step '
                   '(default: 9).')
    p.add_argument('--point2dem-options', dest='point2dem_options', default='',
                   help='Options to pass to point2dem.')
    p.add_argument('--processes', dest='processes', default=None, type=int,
                   help='The number of processes to use per node.')
    p.add_argument('--nodes-list', dest='nodes_list', default=None,
                   help='A file containing the list of computing nodes, one per line. '
                   'If not provided, run on the local machine.')
    p.add_argument('--dem', dest='dem', required=True,
                   help='Input DEM for mapprojection. Required.')
    p.add_argument('--parallel-options', dest='parallel_options', default='--sshdelay 0.2',
                   help='Options to pass directly to GNU Parallel.')

    # Warn about --threads being ignored
    if '--threads' in sys.argv:
        print("Ignoring the option --threads. Use --threads-multiprocess "
              "and --threads-singleprocess.")
        asp_cmd_utils.wipe_option(sys.argv, '--threads', 1)

    (opt, args) = p.parse_known_args()
    args = asp_cmd_utils.clean_args(args)

    if opt.version:
        asp_system_utils.print_version_and_exit()

    if not args and not opt.version:
        p.print_help()
        asp_system_utils.raise_error('Missing input files.', code=2)

    # These are not supported as stereo_dist manages its own crop windows per tile
    for bad_opt in ['--left-image-crop-win', '--right-image-crop-win']:
        if bad_opt in args:
            asp_system_utils.raise_error('The option ' + bad_opt +
                                         ' is not supported by stereo_dist.')

    # Pass the DEM to the stereo C++ tools
    args.extend(['--dem', opt.dem])

    # Validate --tr is in point2dem options when DEM step will run
    if opt.entry_point <= Step.dem < opt.stop_point and '--tr' not in opt.point2dem_options:
        asp_system_utils.raise_error('The option --point2dem-options must include --tr to '
                                     'ensure consistent grid size across all tiles.')

    # Set default threads if not specified
    if opt.threads_single is None:
        opt.threads_single = asp_system_utils.get_num_cpus()

    # Run stereo_pprc with --stop-after-stats to compute statistics only
    asp_cmd_utils.wipe_option(args, '--threads', 1)
    pprc_args = ['--stop-after-stats', '--threads', str(opt.threads_single)]
    stereo_run('stereo_pprc', args, opt, extra_args=pprc_args)

    # Run stereo_parse to generate the tile list and get the output prefix
    tile_params = ['--stereo-dist-tile-params', str(opt.tile_size), str(opt.tile_padding)]
    stereo_run('stereo_parse', args, opt, extra_args=tile_params)

    # Get the output prefix from stereo_parse
    sep = ","
    settings = asp_system_utils.run_and_parse_output("stereo_parse", args, sep, opt.verbose)
    outPrefix = settings['out_prefix'][0]

    # Run stereo_tile on all tiles for pprc only (entry_point=0, stop_point=1)
    if opt.entry_point <= Step.pprc < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.pprc, Step.corr)

    # Run stereo_tile on all tiles for corr only (entry_point=1, stop_point=2)
    if opt.entry_point <= Step.corr < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.corr, Step.blend)

    # Skip blend - in distributed stereo each tile goes to point cloud/DEM independently,
    # then only final DEMs are merged. No cross-talk needed until DEM merging.

    # Run stereo_tile on all tiles for rfne only (entry_point=3, stop_point=4)
    if opt.entry_point <= Step.rfne < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.rfne, Step.fltr)

    # Run stereo_tile on all tiles for fltr only (entry_point=4, stop_point=5)
    if opt.entry_point <= Step.fltr < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.fltr, Step.tri)

    # Run stereo_tile on all tiles for tri only (entry_point=5, stop_point=6)
    if opt.entry_point <= Step.tri < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.tri, Step.clean)

    # Cleanup step (entry_point=6, stop_point=7)
    if opt.entry_point <= Step.clean < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.clean, Step.dem)

    # Run point2dem on all tiles (entry_point=7, stop_point=8)
    if opt.entry_point <= Step.dem < opt.stop_point:
        runStereoTiles(opt, args, outPrefix, Step.dem, Step.mosaic)

    # Mosaic per-tile DEMs into final DEM (entry_point=8, stop_point=9)
    if opt.entry_point <= Step.mosaic < opt.stop_point:
        mosaicDems(opt, outPrefix)

    sys.exit(0)
